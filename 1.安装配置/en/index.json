[
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/docker%E5%AE%89%E8%A3%85/",
	"title": "docker安装",
	"tags": [],
	"description": "",
	"content": " 下面是基于CentOS\n卸载旧版本 旧版本的 Docker 称为 docker 或者 docker-engine ，使用以下命令卸载旧版本：\n$ sudo yum remove docker \\ docker-common \\ docker-selinux \\ docker-engine  使用 yum 源 安装 执行以下命令安装依赖包：\n$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2  鉴于国内网络问题，强烈建议使用国内源，下面先介绍国内源的使用。\n国内源 执行下面的命令添加 yum 软件源：\n$ sudo yum-config-manager \\ --add-repo \\ https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo   以上命令会添加稳定版本的 Docker CE yum 源。从 Docker 17.06 开始，edge test 版本的 yum 源也会包含稳定版本的 Docker CE。\n 官方源 $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo  如果需要最新版本的 Docker CE 请使用以下命令：\n$ sudo yum-config-manager --enable docker-ce-edge $ sudo yum-config-manager --enable docker-ce-test  安装 Docker CE 更新 yum 软件源缓存，并安装 docker-ce 。\n$ sudo yum makecache fast $ sudo yum install docker-ce  使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：\n$ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun  执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 edge 版本安 装在系统中。\n启动 Docker CE $ sudo systemctl enable docker $ sudo systemctl start docker  建立 docker 用户组 默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统 上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。\n建立 docker 组：\n$ sudo groupadd docker  将当前用户加入 docker 组：\n$ sudo usermod -aG docker $USER  镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜 像加速。\n添加内核参数 默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：\nWARNING: bridge-nf-call-iptables is disabled WARNING: bridge-nf-call-ip6tables is disabled  请添加内核配置参数以启用这些功能。\nsudo tee -a /etc/sysctl.conf \u0026lt;\u0026lt;-EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF  然后重新加载 sysctl.conf 即可\n$ sudo sysctl -p  "
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/saltstack%E5%AE%89%E8%A3%85/",
	"title": "saltstack安装",
	"tags": [],
	"description": "",
	"content": " 安装 1.安装阿里镜像源 yum install -y https://mirrors.aliyun.com/saltstack/yum/redhat/salt-repo-latest-2.el7.noarch.rpm  2.配置中的域名修改 仍以 Centos 7 为例，初始化rpm包生成的配置文件为:\n/etc/yum.repos.d/salt-latest.repo  文件中的访问地址需要替换成镜像站的路径，执行命令：\nsudo sed -i \u0026quot;s/repo.saltstack.com/mirrors.aliyun.com\\/saltstack/g\u0026quot; /etc/yum.repos.d/salt-latest.repo  3.安装saltstack 3.1安装saltstack-master和minion yum install -y salt-master  yum install -y salt-minion  4.启动 systemctl start salt-master systemctl start salt-minion  "
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/zabbix%E5%AE%89%E8%A3%85/",
	"title": "zabbix安装",
	"tags": [],
	"description": "",
	"content": " 使用阿里云镜像源 ###替换默认centos源为阿里云的源\ncd /etc/yum.repos.d/ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo  使用阿里云的epel源 备份(如有配置其他epel源) mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo  使用阿里云的zabbix镜像源 cd /etc/yum.repos.d vim zabbix.repo [zabbix] baseurl=https://mirrors.aliyun.com/zabbix/zabbix/3.4/rhel/7/x86_64/ enabled=1 gpgcheck=0  最后执行\nyum makecache  安装zabbix yum install -y zabbix-release //安装源码库配置部署包 yum install -y zabbix-server-mysql zabbix-web-mysql 只安装Zabbix Agent的示例. yum install zabbix-agent  安装mysql数据库 yum install -y mysql-server mysql systemctl enable mysql systemctl start mysql  ##初始化mysql数据库\nshell\u0026gt; mysql -uroot -p\u0026lt;password\u0026gt; mysql\u0026gt; create database zabbix character set utf8 collate utf8_bin; mysql\u0026gt; grant all privileges on zabbix.* to zabbix@localhost identified by '\u0026lt;password\u0026gt;'; mysql\u0026gt; quit;  然后导入初始架构（Schema）和数据。\ncd /usr/share/doc/zabbix-server-mysql-3.4* zcat create.sql.gz | mysql -uroot zabbix  修改http配置 vim +95 /etc/httpd/conf/httpd.conf ServerName 192.168.200.132:80 systemctl restart httpd  修改zabbix时区 vim /etc/httpd/conf.d/zabbix.conf #启用时区设置,并将其改为上海 php_value date.timezone Asia/Shanghai  启动Zabbix Server进程 在zabbix_server.conf中编辑数据库配置\n# vi /etc/zabbix/zabbix_server.conf DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=  启动Zabbix Server进程\nsystemctl start zabbix-server  配置zabbix-agent vim /etc/zabbix/zabbix_agentd.conf #修改其中是Server项 , 让其指向zabbix-server的地址 Server=192.168.200.132  ##访问zabbix\nZabbix前端可以在浏览器中通过 http://zabbix-frontend-hostname/zabbix 进行访问。默认的用户名／密码为 Admin/zabbix\n"
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E4%BD%BF%E7%94%A8kubeadm%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAkubernetesv1.11.1/",
	"title": "使用kubeadm从0开始搭建kubernetes:v1.11.1",
	"tags": [],
	"description": "",
	"content": " [TOC]\n准备阶段 前期准备 准备至少2台机器 (我的是CentOS7 )\n   ip hostname role     192.168.200.139 master 主节点   192.168.200.140 node01 集群从节点    配置hosts文件\nvim /etc/hosts 192.168.200.139 master 192.168.200.140 node01  设置2台机器的hostname\nhostnamectl set-hostname master //在master上设置 hostnamectl set-hostname node01 //在node01上设置  关闭防火墙(在master和node01上执行)\nvim /etc/selinux/config SELINUX=disabled systemctl stop firewalld \u0026amp;\u0026amp; systemctl disable firewalld setenforce 0 iptables -F vim /etc/fstab 注释掉swap那一行 swapoff -a 配置各节点系统内核参数使流过网桥的流量也进入iptables/netfilter框架中，在/etc/sysctl.conf中添加以下配置 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 sysctl -p  设置yum源(在master和node01上都执行) #换成阿里云镜像源 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo #使用阿里云docker镜像 cd /etc/yum.repo.d wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #设置国内加速的kubernetes源 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF  安装docker和kubeadm\nyum install -y docker-ce kubelet kubeadm systemctl enable docker \u0026amp;\u0026amp; systemctl start docker systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet  注意一定要安装docker-ce 而且要定义好docker的repo源 , 如果只是简单的把CentOS的源替换成了阿里源 ,在执行yum install -y docker的时候 下载的docker不是我们要的 ,用命令查看docker version会发现docker的版本是1.13的 安装的时候要安装docker-ce yum install -y docker-ce 安装完成查看版本的话 显示的是\u0026rdquo;18.06.0-ce\u0026rdquo;\n设置docker加速器 #方法1 清华大学的docker加速,感觉速度比阿里云的快 vim /etc/docker/daemon.json 请在该配置文件中加入（没有该文件的话，请先建一个）： { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://docker.mirrors.ustc.edu.cn\u0026quot;] } #方法2 阿里云的加速 访问阿里云的加速网址 https://cr.console.aliyun.com/cn-hangzhou/mirrors 之后登陆自己的账号 点击左边的镜像加速器 就可以看到自己的私有加速地址 修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u0026lt;\u0026lt;-'EOF' { \u0026quot;registry-mirrors\u0026quot;: [\u0026quot;https://gekysrd8.mirror.aliyuncs.com\u0026quot;] } EOF systemctl daemon-reload systemctl restart docker  查看docker是否启动\nsystemctl status docker  编辑kubelet文件\n在kubeadm初始化的时候可能会出现swap错误 v1.11.1其实已经不用再关swap了 以前的版本可能需要关闭 但是现在不需要了\nvim /etc/sysconfig/kubelet KUBELET_EXTRA_ARGS=\u0026quot;--fail-swap-on=false\u0026quot; KUBE_PROXY_MODE=ipvs //启用ipvs 这种service模式这个只有在v1.11.1才能 v1.11.1以下的都不支持  提前准备拉去所需镜像 众所周知,因为被墙的关系所以kubeadm下载镜像的时候会出问题,这个就是比较头疼的了,\n使用kubeadm init之后会出现以下情况:\n或者是这样的\n可以看到发现以下情况:\n 使用的版本是v1.11.1 拉取镜像的各个版本也是v1.11.1 所以 当前kubernetes的版本和拉取镜像的版本要一致对应,高于或者低于当前kubernetes版本都不行 拉取镜像的地址是k8s.grc.io,其实就是在GCE上拉取的,如果没有外网是访问不了的  所以以上问题的出现都是由于不能访问外网,导致docker拉取镜像失败 , 所以我们可以先把需要的docker先拉取下来 , 这样kubeadm就可以正常运行了\nkubernetes安装部署麻烦的情况是众所周知 , 所以已经有人开始做这样的事情了 , 就是做一个google的镜像站 , docker下载镜像的默认的地方是docker hub 在docker hub上做的做好的是mirrorgooglecontainers 里面需要的google容器镜像几乎都有,不过有些最新的还没有更新,待会我会和大家来讲解自己手动来获取最新的google容器镜像\n运行kubeadm init之后 不能获取的镜像已经在报错中列出来了 ,分别是:\nfailed to pull image [k8s.gcr.io/kube-apiserver-amd64:v1.11.1]: exit status 1 failed to pull image [k8s.gcr.io/kube-controller-manager-amd64:v1.11.1]: exit status 1 failed to pull image [k8s.gcr.io/kube-scheduler-amd64:v1.11.1]: exit status 1 failed to pull image [k8s.gcr.io/kube-proxy-amd64:v1.11.1]: exit status 1 failed to pull image [k8s.gcr.io/pause:3.1]: exit status 1 failed to pull image [k8s.gcr.io/etcd-amd64:3.2.18]: exit status 1 failed to pull image [k8s.gcr.io/coredns:1.1.3]: exit status 1  在master提前下好镜像 下一步我们就要来获取这些镜像 在master上编写个脚本如下:\nvim get-k8s-containers.sh //编写脚本从dockerhub上获取这些镜像 #!/bin/bash docker pull coredns/coredns:1.1.3 docker tag coredns/coredns:1.1.3 k8s.gcr.io/coredns:1.1.3 docker rmi coredns/coredns:1.1.3 images=(kube-proxy-amd64:v1.11.1 kube-scheduler-amd64:v1.11.1 kube-controller-manager-amd64:v1.11.1 kube-apiserver-amd64:v1.11.1 etcd-amd64:3.2.18 pause-amd64:3.1 kubernetes-dashboard-amd64:v1.8.3 k8s-dns-sidecar-amd64:1.14.8 k8s-dns-kube-dns-amd64:1.14.8 k8s-dns-dnsmasq-nanny-amd64:1.14.8 pause:3.1) for imageName in ${images[@]} ; do docker pull mirrorgooglecontainers/$imageName docker tag mirrorgooglecontainers/$imageName k8s.gcr.io/$imageName docker rmi mirrorgooglecontainers/$imageName done  之后给脚本加权限\nchmod +x get-k8s-containers.sh  之后运行脚本\n./get-k8s-containers.sh  在node01上提前下载好镜像 ,编写脚本如下:\nvim get-k8s-node-images.sh #!/bin/bash docker pull haojianxun/flannel:v0.10.0-amd64 docker tag haojianxun/flannel:v0.10.0-amd64 quay.io/coreos/flannel:v0.10.0-amd64 docker rmi haojianxun/flannel:v0.10.0-amd64 images=(kube-proxy-amd64:v1.11.1 pause:3.1 etcd-amd64:3.2.18) for imageName in ${images[@]} ; do docker pull mirrorgooglecontainers/$imageName docker tag mirrorgooglecontainers/$imageName k8s.gcr.io/$imageName docker rmi mirrorgooglecontainers/$imageName done chmod +x get-k8s-node-images.sh //脚本加上执行权限 ./get-k8s-node-images.sh //运行脚本  初始化kubeadm kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 //如果要使用flannel网络插件,可以在初始化的时候就指定flannel网络地址 kubeadm init --kubernetes-version=v1.11.1 //不指定其他网络插件具体地址  稍等几分钟就可以看到\nnode01加入机器\n列出集群状态\nkubectl get nodes //在主节点上查看  可以看到status是NotReady状态 原因是没有安装cni网络插件\n安装网络插件 方法1:安装flannel插件\nflannel官方的github地址是: https://github.com/coreos/flannel 对于Kubernetes v1.7以上的版本 都可以直接运行如下命令: kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 之后运行命令 查看images是否running起来了 kubelet get pods -n kube-system -o wide 查看当前命名空间 kubelet get ns 查看集群是否起来了 kubelet get nodes //显示ready状态就是起来了 注意: 如果要开启flannel的directrouting功能的话 可以先wget下这个yaml文件 之后再修改配置 操作如下: 1.先下载yaml文件 wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 2.编辑刚刚下载好的文件 vim https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 找到如下片段: net-conf.json: | { \u0026quot;Network\u0026quot;: \u0026quot;10.244.0.0/16\u0026quot;, \u0026quot;Backend\u0026quot;: { \u0026quot;Type\u0026quot;: \u0026quot;vxlan\u0026quot; } } 再原来基础上加上directrouting功能 ,修改完成之后应该是这样的: net-conf.json: | { \u0026quot;Network\u0026quot;: \u0026quot;10.244.0.0/16\u0026quot;, \u0026quot;Backend\u0026quot;: { \u0026quot;Type\u0026quot;: \u0026quot;vxlan\u0026quot;, \u0026quot;Directrouting\u0026quot;: true } } 之后保存退出 之后再应用: https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 这样以后各个节点通信的话 就是通过物理网卡直接通信了 可以用ip route show 命令查看规则 , 在节点上用tcpdump -i ens32 -nn icmp 抓包看  方法2:安装weave网络插件\n我们 选择weave 当然在初始化的时候没有指定特殊网络才行 kubectl apply -f https://git.io/weave-kube-1.6 之后运行kubectl get nodes即可看到是ready状态  稍等片刻 下载好之后 在master上执行如下命令, 可以查看是否集群已经起来了\nkubectl get pod -n kube-system -o wide //都是running就是正常的 kubelet get nodes //可以看到master和node02都是ready状态  可能出现问题和解决方法 无法拉去k8s.gcr.io相关的镜像 方法1:http代理 最简单的解决方法是设置http代理\ndocker官方给出的设置http代理方法如下:\ndocker http_proxy\n设置http代理的好处就是一劳永逸 , 不用再哭哈哈的编写脚本 ,提前拉去镜像 , 也不用再把墙外的google镜像拉到国内再下载 之后打tag\n设置http代理之后就可以直接运行kubeadm了 其他一切都不需要额外设置\n我们可以这样来设置http代理\n1. vim /usr/lib/systemd/system/docker.service 在[Service]中添加如下信息 Environment=\u0026quot;HTTP_PROXY=http:xxxxx:80\u0026quot; Environment=\u0026quot;NO_PROXY=127.0.0.0/8,192.168.0.0/16\u0026quot; #这里的192.168.0.0/16是自己本地的网络,替换成自己的本地网络地址 #NO_PROXY的意思就是要走本地网络的就不需要来代理了,直接走本地网络即可 2. 编辑完成之后执行如下命令: systemctl daemon-reload systemctl start docker  可以用docker info查看具体信息 看看http_proxy有没有设置好, 当然如果是有公司的未批嗯的话最好,没有的话 可以google一个 由于敏感 这样就不放出来了 ,http代理网上一大堆 可以直接用搜索引擎找一个\n下面列出几个比较好用的http代理网站\nhttp://cn-proxy.com/archives/218\nhttps://www.kuaidaili.com/free/intr/\nhttp://www.66ip.cn/\nhttp://www.xicidaili.com/\nhttp://www.coobobo.com/\n方法2:使用中转站来拉去镜像  一般来说 ,由于网络被墙 , 许多人开始做这个工作了 , 就是把google的相关镜像拉去到dockerhub上 , 之后我们在dockerhub上来下载所需的镜像 , 在安装特定的版本的时候会要求特定的镜像 , 这个时候可以去mirrorgooglecontainers 找 , 如果版本没有更新 ,可以试试以下方法:  首先 能科学上网 , 可以在自己浏览器的插件市场上下载一个 ,比如\u0026rdquo;谷歌访问助手\u0026rdquo; 等等 , 垃圾的也行 , 只要能访问外网就成 , 不要求网速.\n在执行kubeadm init的时候对于没有拉取下来的镜像,可以直接到k8s.gcr.io/google_containers 下载\n 启动控制台    以kube-apiserver-amd64为例子 ,搜索kube-apiserver-amd64  点击kube-apiserver-amd64 我们安装v1.11.1的 点击标记为v1.11.1的镜像\n 运行拉取命令   中转镜像 , 把镜像拉取出来传到dockerhub上自己的仓库 之后拉取push上的镜像    docker获取刚刚上传的镜像并打上k8s.gcr.io/的前缀tag   docker pull haojianxun/kube-apiserver-amd64:v1.11.1 docker images //列出刚刚下载的镜像 docker tag kube-apiserver-amd64:v1.11.1 k8s.gcr.io/kube-apiserver-amd64:v1.11.1  最后镜像下载完成\nkubeadm init可能出现的报错 先去看kubeadm的帮助信息\nkubeadm --help //这样会列出许多帮助信息  要想使用flannel网络,在初始化的时候就先指定网络\nkubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16  如果出现[ERROR Swap]\nvim /etc/sysconfig/kubelet KUBELET_EXTRA_ARGS=\u0026quot;--fail-swap-on=false\u0026quot; 编辑完成之后在kubeadm init后面加个参数 kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 --ignore-preflight-errors Swap  "
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/saltstack%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE/",
	"title": "初始化简单配置saltstack",
	"tags": [],
	"description": "",
	"content": " MASTER的主要配置 网络接口 默认: 0.0.0.0 (所有的网络接口都可访问)\n绑定本地接口\ninterface: 192.168.200.132  MINION的主要配置 MASTER 缺省:salt\n主机名或者master的IPV4地址。\n缺省:salt\nmaster: 192.168.200.132 //这个master的地址填上salt-master的ip地址  为SALT开启防火墙配置 在Salt minions端没有设置防火墙的必要。下面的配置只是涉及master。\nfirewall-cmd --permanent --zone=\u0026lt;zone\u0026gt; --add-port=4505-4506/tcp //如果没有区域可以去掉--zone firewall-cmd --permanent --add-port=4505-4506/tcp  MASTER端白名单 # Allow Minions from these networks iptables -I INPUT -s 10.1.2.0/24 -p tcp -m multiport --dports 4505,4506 -j ACCEPT iptables -I INPUT -s 10.1.3.0/24 -p tcp -m multiport --dports 4505,4506 -j ACCEPT # Allow Salt to communicate with Master on the loopback interface iptables -A INPUT -i lo -p tcp -m multiport --dports 4505,4506 -j ACCEPT # Reject everything else iptables -A INPUT -p tcp -m multiport --dports 4505,4506 -j REJECT  MINION开启iptables规则 iptables -A INPUT -m state --state new -m tcp -p tcp --dport 4505 -j ACCEPT iptables -A INPUT -m state --state new -m tcp -p tcp --dport 4506 -j ACCEPT  KEY管理 Salt在Master和Minion之间的通讯采用AES加密. 这就确保了发送给minions的命令不会被篡改， Master和Minion之间的通讯认证通过信任的已接受的key进行管理.\n在发送给Minion之前，需要确保minion的key已经被Master所接受. 运行 salt-key命令将列出Salt Master已知的所有keys\n[root@node01 salt]# salt-key -L Accepted Keys: node01 Denied Keys: Unaccepted Keys: node02 Rejected Keys:  使用salt-key -A 来接受key以使Mionions可以被Master管控\n[root@node01 salt]# salt-key -A The following keys are going to be accepted: Unaccepted Keys: node02 Proceed? [n/Y]  输入y 接受\n[root@node01 salt]# salt-key -A The following keys are going to be accepted: Unaccepted Keys: node02 Proceed? [n/Y] y Key for minion node02 accepted.  当然可以使用salt-key -a 来使用通配符来选择接受 , 具体命令可以使用帮助查看salt-key -h\n测试是否成功 salt '*' test.ping  如果成功则显示true ,我在本机测试如下:\n[root@node01 salt]# salt \\* test.ping node01: True node02: True  可能出现的报错 如果minion一直识别不了 , 表现为执行salt-key -L ,命令输出中 Unaccepted Keys 的没有minion的, 可以去查看日志\n查看minion报错日志\ntail /var/log/salt/minion  如果出现的报错是这样的\n[ERROR ][4076] Error while bringing up minion for multi-master  则就是防火墙和iptables没有搞好 , 可以去添加防火墙和iptables规则 , 在学习的过程中 , 如果嫌麻烦可以直接关掉防火墙\nsystemctl stop firewalld  "
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E5%AE%89%E8%A3%85zsh/",
	"title": "安装zsh",
	"tags": [],
	"description": "",
	"content": "1.查看当前系统有哪些shell\ncat /etc/shells 如果没有zsh就进行安装  2.安装zsh\nyum install -y zsh //CentOS系统 apt-get install -y zsh //ubuntu系统 #如果没有安装curl或者wget或者git 建议安装一下 yum install -y curl wget git 查看是否安装成功 zsh --version  方法1: 使用脚本安装 sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot; 或者使用wget获取脚本 sh -c \u0026quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\u0026quot; 安装完成之后可以修改主题: 在家目录下 vi ~/.zshrc 修改ZSH_THEME=\u0026quot;agnoster\u0026quot; #主题预览地址:https://github.com/robbyrussell/oh-my-zsh/wiki/Themes 方法2: git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc chsh -s /bin/zsh vi .zshrc ZSH_THEME=\u0026quot;agnoster\u0026quot; # (this is one of the fancy ones) # see https://github.com/robbyrussell/oh-my-zsh/wiki/Themes#agnoster  zsh搭配git\n"
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/",
	"title": "安装配置",
	"tags": [],
	"description": "",
	"content": " 哇啊哇 沙大袋鼠\n"
},
{
	"uri": "https://haojianxun.github.io/docs/en/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/%E9%80%9A%E8%BF%87onedrive%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%BD%91%E7%9B%98/",
	"title": "通过onedrive搭建私人网盘",
	"tags": [],
	"description": "",
	"content": "具体项目地址: https://github.com/donwa/oneindex\n我们可以用docker来运行它\ndocker run -d -p 8080:80 --name onedrive --restart=always yinaoxiong/oneindex  之后打开我们阿里云服务器的地址的8080端口就可以了(前提是把8080端口放开)\n之后进入安装页面\n其中\n获取程序的id和secret\n地址: https://apps.dev.microsoft.com/#/appList\n填入之后 就会跳转到登陆页面 , 登陆微软账号, 或者是office365账号(网上很多这种账号 里面onedrive空间是5T)\n绑定即可 之后就搭建完成\n"
},
{
	"uri": "https://haojianxun.github.io/docs/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://haojianxun.github.io/docs/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://haojianxun.github.io/docs/en/",
	"title": "郝建勋的运维文档",
	"tags": [],
	"description": "",
	"content": ""
}]